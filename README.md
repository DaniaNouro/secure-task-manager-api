# Secure Task Manager API

"A secure REST API for managing personal tasks, built with Spring Boot and secured with Keycloak (JWT-based authentication and authorization)."

## Features

- Role-based access control using Keycloak
- CRUD operations on personal tasks
- Only task owners can access/update/delete their tasks
- Input validation with `@Valid` annotations
- Global exception handling with meaningful JSON error responses
- Clean DTO-based structure (no entity exposure)
- JWT-based authentication & authorization

You can set up Keycloak manually or by importing the provided configuration file.

### Option 1: Manual Setup

1. **Create a Realm**: `secure-task-manager`
2. **Create a Client**:
   - Name: `task-manager-api-client`
   - Type: *confidential*
   - Enable: `Direct Access Grants`
3. **Create Role**: `client-user`
4. **Create User**:
   - Assign role `client-user`
   - Set a password

### Getting a JWT Token

Use this endpoint to log in and obtain a JWT:
POST http://localhost:8080/realms/task-manager-api/protocol/openid-connect/token
Content-Type: application/x-www-form-urlencoded
grant_type=password
client_id=task-manager-api-client
username=your-username
password=your-password


### Postman Collection

You can test the API using the provided Postman collection:

[Download Postman Collection](postman/task-managment.postman_collection.json)

-------------------------------------------------------------------------

## Authorization Logic

The application enforces two levels of authorization:

### 1. Role-based Access Control (RBAC)

Implemented using the `@PreAuthorize` annotation at the controller level.

Example:
@PreAuthorize("hasRole('client-user')")

This ensures that only users with the client-user role—assigned in Keycloak—can access the protected endpoints.

2. Task Ownership Check
Beyond role checking, we enforce resource-level authorization to ensure that a user can only view, update, or delete their own tasks. This logic is implemented in the Service Layer, not via @PreAuthorize, for the following reasons:

Verifying task ownership requires accessing the database (to fetch the task by ID and compare its ownerId with the authenticated user's ID).

Such dynamic, data-dependent logic cannot be handled easily or safely inside SpEL expressions used by @PreAuthorize.

Instead, we perform this check explicitly in the service methods:

if (!task.getOwnerId().equals(authenticatedUserId)) {
    throw new UnauthorizedTaskAccessException("You do not have access to this task");
}

Why the Service Layer?
Clarity: The service layer already contains business logic. Placing the authorization logic here makes it more readable and maintainable.

Control: It allows throwing custom exceptions with detailed messages, which are then mapped to proper error responses by the global exception handler.

Flexibility: Easier to extend in the future (e.g., if you want to allow admins to bypass this check, etc.).

Keycloak Integration & JWT Extraction
Keycloak is used as the Identity Provider (IdP) and issues JWTs upon successful authentication. These tokens are then sent with API requests via the Authorization: Bearer <token> header.

How JWT Validation Works
Spring Security is configured to delegate authentication to Keycloak via OAuth2ResourceServer.

A custom JwtAuthenticationConverter is used to extract the user ID from the sub claim and inject it as the Authentication principal.

This user ID is then used in the service layer to associate tasks with users and enforce ownership checks.

Example:

var authentication = SecurityContextHolder.getContext().getAuthentication();
This ensures that task ownership and access control are always linked to the authenticated user's identity, as defined in their JWT.
----------------------------------------------------------------------------------------------
##JPA/Hibernate Setup
In the "Secure Task Manager API" application, we used JPA/Hibernate to structure and interact with the database. Here are some decisions made regarding JPA:

Entity Mapping: The Task class is marked as an @Entity, indicating that it will be persisted in the database.

Table Name: The table name for the Task entity is specified using @Table(name="tasks").

Primary Key and Auto-Generation: The id field is marked with @Id to indicate it is the primary key of the table. The @GeneratedValue(strategy = GenerationType.IDENTITY) annotation ensures that the id is auto-generated by the database.

Owner ID Field: The ownerId field is used to associate each task with a specific user. The @Column(nullable = false) annotation ensures that this field is non-null in the database, which is crucial for associating a task with its owner.

Custom Queries for Task Ownership: The method findByOwnerId(String ownerId) in the TaskRepo allows querying tasks by the ownerId field. This retrieves all tasks associated with a specific user, based on their user ID.

Hibernate Configuration: The database used is MySQL, and the appropriate Hibernate Dialect is set in the application.properties file to ensure compatibility with MySQL.
-----------------------------------------------------------------------------------------------
##Significant Challenges and Resolutions
Docker and Keycloak Integration
One of the initial challenges was setting up the Docker environment along with Keycloak for proper integration. Specifically, configuring Keycloak roles and ensuring seamless communication between Keycloak and the Spring Boot application took some time to get right. After troubleshooting, the system was successfully configured, and the roles were correctly mapped, enabling secure authentication and authorization.

Lombok Issues
Another challenge was related to Lombok, which caused issues with recognizing the constructors and methods in the code. Lombok was initially used to generate getters, setters, and constructors, but it caused some difficulties during development. As a result, I opted to manually implement getters and setters instead of relying on Lombok, which resolved the issue and made the codebase more straightforward to work with.
-----------------------------------------------------------------------------------------------
# Note

Docker files have been added in another branch. Please check that branch for the latest updates regarding the Docker setup.

## Docker Setup Explanation

In this project, we have utilized Docker to create a consistent development and production environment. The following steps were taken to set up Docker:

1. **Dockerfile Creation**: A Dockerfile was created to define the environment for the application. This file includes instructions on how to build the application image, including installing dependencies, setting environment variables, and specifying the command to run the application.

2. **Docker Compose**: A docker-compose.yml file was created to manage multi-container applications. This file defines all the services required for our application, such as the web server and database. It allows us to easily configure and start all services with a single command.

3. **Building and Running**: To build the Docker image, we used the command docker build -t <image-name> . in the directory containing the Dockerfile. To run the application and its services, we executed docker-compose up, which starts all defined services in the background.

By using Docker, we ensure that our application runs consistently across different environments, simplifying deployment and reducing issues related to environment configuration.

